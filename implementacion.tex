% - MTSA
%     Herramienta, sintaxis
% - Tests 
%     Qué tests desarrollamos, quizás mostrar un par interesantes y explicarlos

El algoritmo fue implementado en el lenguaje Java, agregando a la funcionalidad del programa Modal Transition System Analyser (MTSA)\cite{mtsaRepo}.

\section{MTSA}
El software utilizado cuenta con una gran cantidad de funcionalidad. Principalmente nos interesa la forma de escribir Labelled Transition Systems (LTS), esto se puede hacer mediante Finite State Process (FSP). En el listing~\ref{ejLTS} podemos ver un ejemplo donde se declara un LTS llamado $MiLTS$, el mismo tiene como estado inicial $A0$. Este estado puede ir por $c01$ a $A1$, $A1$ se declara en la linea siguiente. Tenemos la información entonces de cada estado y sus transiciones. Además se pueden componer las distintas LTSs con el comando \texttt{||}.

\begin{lstlisting}[language = mtsa, caption=Ejemplo de LTS y composición, label=ejLTS]
MiLTS = A0,
A0 = (c01 -> A1),
A1 = (u12 -> A2 | u13 -> A3),
A2 = (u23 -> A3),
A3 = (u33 -> A3).

OtroLTS = B0,
B0 = (c01 -> A1),
B1 = (u12 -> A2 | u13 -> A3),
B2 = (u23 -> A3 | inicial -> A1).

|| Compuesto = (MiLTS || OtroLTS).
...
\end{lstlisting}
QUIZAS CAMBIAR LOS EJEMPLOS POR UNOS MENOS HORRIBLES

En el listing~\ref{ejController} vemos un ejemplo de cómo definir un controlador, en este caso lo llamamos $Goal$. En el área de \textit{Automated planning} el objetivo es alcanzar algún estado \textit{final}, es decir, los estados son los marcados; sin embargo en el contexto MTSA y al representar el problema con LTSs solo podemos marcar transiciones. La interpretación final es que las transiciones señaladas como \textit{marcadas} llevan a estados marcados y estos serán nuestros objetivos. En el ejemplo se declara la transición $u12$ como marcada, por ende el estado $A2$ estará marcado. Luego definimos el conjunto de transiciones controlables, en este caso solo $c01$. Luego debemos agregar la palabra clave \texttt{nonblocking}, en caso contrario se intentará, por defecto, resolver \textit{blocking}.

En la última línea utilizamos la palabra clave \texttt{heuristic} para aclarar que queremos utilizar el algoritmo de DCS, luego le damos el nombre de $DirectedController$ y lo definimos como el LTS $Compuesto$ dirigido bajo el controller $Goal$.

\begin{lstlisting}[language = mtsa, caption=Ejemplo de Controller y DCS, label=ejController]
...
controllerSpec Goal = {
    marking = {u12}
    controllable = {c01}
    nonblocking
}

heuristic ||DirectedController = Compuesto~{Goal}.
\end{lstlisting}


\section{Testing}
Luego de haber presentado la sintaxis con la cuál desarrollamos nuestros tests vamos a hablar un poco de ellos y qué es lo que se esperaba en cada uno. 

%TODO AGREGAR LOS TESTS QUE NOS HICIERON DAR CUENTA QUE EL PROPAGATE NO PODIA SER LOCAL Y HABIA QUE MARCAR ERRORES AL TERMINAR DE EXPLORAR ALGO

TO ADD\\

%TODO correr todos los tests de nuevo con la version de la tesis de dani y ver cuales fallan

- TEST 1, Cuando encuentra el primer loop no controlable, propaga mal WEAK, cuando vuelve a ver el nodo inicial. El problema es que no vuelve a poner al nodo inicial en open, entonces no ve el otro camino, que lleva al goal.\\

- TEST 7, caso donde encontraba un loop que pensaba era goal pero luego, recién al querer crear controloador, fallaba porque tenía cosas por explorar. Esto era doblemente malo porque se puede tener una conclusión erronea y no se sigue explorando.\\

- TEST 19, 22, daban que no habia controlador y son controlables

- TEST 26? este puede ser interesante porque son dos loops no controlables pero ganas en ambos\\

- TEST 35 El tema es que arma un CCC y no chequea que sea valido bien, porque ya no hay loop con marcado. Entonces el build Controller se queja y da que no hay controlador. Pero si revisaba para el otro lado había un CCC válido

\begin{lstlisting}[language = mtsa, caption=Ejemplo de test]
Ejemplo = A0,
A0 = (c01 -> A1),
A1 = (u12 -> A2 | u13 -> A3),
A2 = (u23 -> A3),
A3 = (u33 -> A3).

||Plant = Ejemplo.

controllerSpec Goal = {
controllable = {c01}
marking = {u33}
nonblocking
}

heuristic ||DirectedController = Plant~{Goal}.
\end{lstlisting}
