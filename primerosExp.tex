\section{Primeros experimentos}

%Ponemos que no marcaba errores y por eso no estaba seguro de donde habia explorado y donde no? Podriamos usarlo para motivar que nuestro invariante es saber siempre que cosas exploramos, que consideramos clave para un algoritmo de clasificacion on the fly.

Como parte inicial de comprender el código y al notar una falta de batería de tests, decidimos crear los propios. 

%Consiste de casos chicos, simples desde el punto de vista de alguien con grafos en mente, complicados e incluso inexistentes desde el de alguien que trabaja con non-blocking. Nuestra falta de experiencia en el tema nos jugó a favor y creamos casos que rompían el algoritmo de exploración. 

Dada nuestra falta de experiencia en el tema, no estábamos sesgados por las formas típicas de los problemas en el campo. Eso nos llevó a generar casos de tests muy pequeños, muy simples analizados como un grafo, pero con formas poco usuales para un problema de síntesis de controlador non-blocking. Esto fue clave para encontrar los problemas en el algoritmo de exploración, ya que éstos no aparecían al sintetizar problemas típicos del área, si no forzando a la herramienta a casos borde.  

EXPLICACION SOBRE TEST 6 Y QUE ES LO QUE QUERIAMOS VER? PONER EXPLICACION DE LA HERRAMIENTA Y COMO MARCA CON TRANSICIONES.

\begin{lstlisting}[language = mtsa, caption=Test 1]
Ejemplo = A0,
A0 = (c01 -> A1),
A1 = (u12 -> A2 | u13 -> A3),
A2 = (u23 -> A3),
A3 = (u33 -> A3).

||Plant = Ejemplo.

controllerSpec Goal = {
controllable = {c01}
marking = {u33}
nonblocking
}

heuristic ||DirectedController = Plant~{Goal}.

\end{lstlisting}

Con la iteración de bugfixes y nuevos tests, vimos que en gran cantidad de casos, el algoritmo evitaba mostrar errores del código ya que la heurística elegía los caminos a explorar menos problemáticos. En consecuencia, creamos una heurística "dummy" que simplemente elija las transiciones en orden lexicográfico, permitiéndonos un control total del orden de exploración y pudiendo así encontrar más errores en el algoritmo.

Notamos una razón común por la cuál no funcionaba y era la falta de reconocimiento de errores. Anteriormente el algoritmo de exploración solo veía como error a los estados señalados como tal (deadlocks), al encontrar un loop donde no podía ganar solo no lo caracterizaba como ganador y quedaba explorado pero sin conclusión sobre el mismo.

Esto puede ser un problema en casos como el de la figura 1 //TODO (es el ej de facas), donde si exploramos la transición de abajo primero y no concluimos que el estado `e` es un error al mirar la de arriba vamos a pensar, erróneamente, que es un goal y propagaremos esa información.

Cabe aclarar que sólo podemos concluir que un loop es error cuando este ha sido explorado en su completitud. Esto es así debido a la naturaleza optimista de los problemas non-blocking.

Fue a causa de esta necesidad de marcar errores que decidimos finalmente dejar de buscar `fixes` y comenzar a diseñar un nuevo algoritmo con un invariante que consideramos clave para síntesis on-the-fly: Si con la información de lo explorado hasta el momento es posible concluir que un estado es ganador o perdedor en la planta totalmente explorada, debemos marcar ese estado antes de seguir explorando. Este nuevo enfoque se explica en mayor profundidad en la sección 3.





