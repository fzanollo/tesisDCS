En esta sección presentamos el nuevo algoritmo \DCS, que realiza una exploración sobre la marcha del espacio de estados. Por medio de dicha exploración el algoritmo encuentra una solución al problema composicional de "supervisory control". También discutimos la correctitud y completitud del nuevo algoritmo \DCS. \\

\section{Problemas encontrados}
%En problema con solución actual plantearía entre otras cosas que el best first search tiene que ser correcto para cualquier heuristica y que eso no se cumpía. Plantearía el suite de regresión que armaron y com tuvieron que harnesear el tema de la heuristica para mostrar algunos bugs

ADEMAS EL PROPAGATE NO PODIA SER LOCAL, EXPLICAR.

El anterior algoritmo de exploración tenía falencias en cuanto a agregar estados al conjunto $\Errors$. Esto se debía a que no sacaba conclusión alguna al haber explorado todo un subgrafo, por ende al propagar información desde otra rama se podría llegar a un resultado erroneo. Para comprender mejor observar la figura (INGRESE FIGURA) donde desde el estado e tenemos dos sub-ramas a explorar. Si se mira primero la de abajo y no lo marcamos como error entonces al mirar la de arriba diremos que es goal y propagaremos dicha información, equivocadamente, más allá de e.

Cabe aclarar que sólo podemos concluir que un loop es error cuando este ha sido explorado en su completitud. Esto es así debido a la naturaleza optimista de los problemas non-blocking.

Fue a causa de esta necesidad de marcar errores que decidimos diseñar un nuevo algoritmo con un invariante que consideramos clave para síntesis on-the-fly: Si con la información de lo explorado hasta el momento es posible concluir que un estado es ganador o perdedor en la planta totalmente explorada, debemos marcar ese estado antes de seguir explorando.

EXPLICAR QUE NUESTRO ALGORITMO ES AGNÓSTICO A LA HEURÍSICA (COMO DEBERÍA)

%Subiría de nivel el “Nuevo algoritmo”. Trataría de explicar tempranamente la idea de construcción de núcleos de posibles zonas perdedoras o ganadoras optimistas y pesimistas y la propagación. Incluso con la formalización primero.

\section{Propuesta de nuevo algoritmo}

\input{pseudocode.tex}

\FloatBarrier

\section{Demostración de corectitud y completitud}
\input{prueba.tex}

\section{Demostración de Lemas}
\input{lemmaProofs.tex}
